I've always enjoyed this quote by Abraham Lincoln: "Give me six hours to chop down a tree and I will spend the first four sharpening the axe."  It's a great quote about how a little preparation goes a long way.  It really rings a note of truth.  I've thought about that and how it applies to creating software.  After two decades of experience, you may be surprised by what I have to say.

![Axe Sharpening](/images/axe-sharpening.gif)
We all know that technology moves at blazing speeds.  One of the rich things about our industry is that it is brimming with exciting ideas.  This of course means we developers are very often enticed into jumping onto a new bandwagon.  I know.  I spend a good deal of my free time reading up on and playing with these technologies.  Call it intellectual candy, it's an enjoyable way to spend an afternoon.  I've exposed myself to dozens and dozens of technologies and learned a little about a lot of them.  I enjoy the cross pollination of exploring and combining ideas from different camps. 

I think there's a great deal of value in being a generalist.  For one, it really contributes to what ideas I bring to the workplace when we're brainstorming about some design dilemma.  In my locale the majority of software is built on the .NET platform and so that's mostly what I've done professionally.  However, despite the area's affinity for .NET I've always had an affinity for open source platforms and ideas.  I took it unto myself to learn and master Ruby and JavaScript and it was this endeavor that most opened me to new ideas about how to approach and solve problems.  My continued exploration lead me to the Structure and Interpretation of Computer Programs which I consider the most eye opening book I've read on programming.  Exploration leads to learning new languages and that leads to new communities and ideas.  Honestly, it's for having become an explorer that I attribute my insight for solving technical problems. 

I've gained more by learning other languages than I ever would have gained by concentrating on one.  I remember speaking to the contractor whom I replaced when I ended up on my current contract.  I asked him what other languages he liked and he replied that he wanted to concentrate on being good at just the one.  I once felt that way; however, had I held tightly to that view, I would have never gained as much breadth of perspective.

When you learn a new language well it opens you up to a whole new community and its ideas and perspectives.  Although I enjoy my .NET work, some of my most valuable learning moments came from my cross exposure to the Ruby and JavaScript communities.  Sometimes it was just little ideas that captured my attention.  When I first learned JavaScript, I learned just enough to squeak by.  And after learning some basics and wanting more, I ended up exploring Prototype.js and jQuery.  Eventually, I set my focus on jQuery and while working with it I learned about Promises and the shiny goodness of asynchronous non-blocking callbacks.  The API is sheer beauty and a design pattern I still delight in using.  So in addition to improving the user experience by making an app more responsive they improve the coding experience.  Of course, in learning jQuery, I eventually dove head first into JavaScript and made that one of my primary languages.  Node came later.  Being evented in principle, it practically took the idea of promises (ok, callbacks) and built a platform around it.  But what I love most is that because it's JavaScript it makes sharing client and server code possible.  Having to repeat server code on the client, in any capacity, is to me an abomination, a problem worth solving.

When it comes to making something, we often start by choosing the technologies on which to build our foundation.  That task is complicated by an ever changing technological landscape.  I started web development in the early days of ASP (now known as Classic ASP) which is pretty much Microsoft's flavor of PHP.  As with every technology, newer, shinier technologies rendered it obsolete.  With an array of exciting new technologies to choose from, I decided to retool.  I was very much open to the idea of selecting an open source platform despite my locale's affinity for Microsoft technology.  I was open to whatever platform best matched my own philosophies.  I spent almost a month exploring the possibilities and methodologically eliminating them until I finally settled on Rails.  It's underlying philosophies aligned with my own and Ruby, in its amazing brevity, was itself a thing of beauty.  Up until that time I had been using my own homegrown ASP framework which, as tossed together as it was, espoused the Rails-touted idea of convention over configuration – again aligning itself well with my way of thinking.  The language, the community, the platform, looked great – there was even this Ryan Bates guy who was giving away utterly fabulous RailsCasts videos  -- and I vowed this would be the platform to end all platforms.  (Don't get me wrong.  As much as I love technology I can't imagine having to replace and relearn a platform every few years.  I expect a reasonably good ROI for the years that it takes to become decent at something.) 

I bought and gobbled up at least a dozen Rails and Ruby books and I built my church an elaborate Radiant CMS site with a host of customizations including Google calendar integration at a time when no established Ruby clients existed.  For a time I was completely Ruby focused and began scratching some of my own itches with projects that mattered to me – one of which I started by building the server modules.  When I got around to the client I noticed that I was having to build a lot of the same constructs I had already built on the backend.  This was unsettling.  I began to explore how others were addressing this duplication of effort.  

I discovered Node.  This was perhaps a couple years after its release.  The idea that the client and server could share the same code was a godsend but also a serious punch in the gut.  To capitalize on code sharing I was now considering rewriting the backend in JavaScript.  Lacking foresight in my development approach, I had painted myself into this corner.  That's the danger of tunnel vision and not stopping to think.  As a coder, it's important to sometimes pause long enough to reassess where you are and where you're going.

Anyway, it was just around this time that I had started to notice the trend toward rich client applications where the backend was nothing more than a faceless REST API.  I had already been thinking about this myself for a number of years.  During a project early in my career I had been wondering about how to build faceless applications.  The idea first occurred to me when I had a GUI application I developed interface directly with [pkzip]( http://www.pkware.com/software/pkzip) for compression/decompression.  Such console apps were very much black box services, some of which themselves were wrapped by actual GUIs.  At that point in my career I had not yet learned about the Unix way and the beauty of piping single-purpose console tools together.  I had simply wondered, wouldn't it be great if every GUI was built on top of a console application.  That thought, though flawed, did uphold the greater truth of the importance of separating concerns.  That's why when I later helped develop an SOA the idea reemerged.  "This application is nothing more than a blackbox of business logic with an endpoint API.  All applications should be built this way!"  But in my experience most enterprise applications tightly couple interfaces with business logic.  Why are so many enterprises missing the boat?!  That was then and this is now.  Faceless server applications whose GUIs are generated client side are common today.  And dozens of frameworks have sprung up to support the approach.  Is it a good approach?  Well, I like it.  It's the approach my gut has been itching me to follow for years.

But here's the rub.  When I first committed to Ruby/Rails I had forgotten that itch.  I got tunnel vision all over.  I loved what the platform offered and without a doubt I enjoyed developing in Ruby more than I ever did in ASP.  That's the nature of technology.  New ideas are a thrill to explore and usually improve on what came before.  Though I had originally planned to remain a Rubyist indefinitely, the idea of a homongeneous JavaScript codebase compelled me to make Node my platform of choice.  So as is often the case with technology, I am starting over yet again.  I would love for Ruby to be a client side option without transcompilation.  (Think about it.  Why shouldn't browsers allow any language to be plugged in?) It's an terrific language, but favoring a homogeneous codebase for now means Node.

That's the big deal about technology jobs. Learning is never ending and very often you're having to throw away large investments.  Fortunately, ideas build on one another and so there's never a total loss.  That brings me a step closer to my conclusion.

I've worked amazingly hard to learn technology.  I'm confident that I've put in far more time sharpening my axe that the average developer in shops where I've worked.  When you factor that in, it might make a salary that would otherwise be considered lucrative appear less so.  Crafting good software is immensely satisfying, so honestly, I can't help but pursue the craft.  Knowing just which screw to tighten and which part to replace to make things work better is rewarding in and of itself.  

Lincoln's wisdom recognizes the importance of preparation.  His quote reflects a 2:1 ratio of preparation to work.  I have to wonder at that.  Is it practical to spend twice as much time preparing as doing?  Who goes to university for twice as long as his intended career?

To add a little color, I've worked with other developers and very often I'm extremely critical about how they code.  I often feel there's a better a way something could have been done, a cleaner separation of concerns, a way to make a section more maintainable for the next guy.  However, over the years, I've gotten to know some developers, ones who are probably less obsessed with the fine details of craftsmanship are more concerned with building useful, working software.  Some have plenty of side work and have produced numerous applications for their clients.  They've responded to and satisfied their customers needs.  That's practical.

This leads me to my point.  It's possible to be too prepared.  That is, perspiration should not generally be commensurate with preparation; it should eclipse it.  We learn a craft that we may do something with it, not for sheer academics.  It's more about the whats than the hows, the ends than the means.  The fellow who produces good-enough code and meets many needs by making well-used products is more pertinent than the fellow who produces superior code but meets fewer needs. 

Hold your rebuke for a minute.  I realize that all software carries with it ongoing costs, some call it technical debt and that very often that's why we rewrite legacy software.  I'm definitely not advocating that all software is created equal and I realize that bad decisions can negatively impact the cost of ongoing maintenance.  I'm just saying that we need to sometimes recognize that perfectionism has costs of its own.  We can very often get caught up in right vs. wrong when what we should be concerned with is what -- what's the need and how can I best meet it?  So long as we can sustain that at a reasonable cost, we add value to the world.  It doesn't matter that we sometimes implement suboptimal designs if those decisions pose a negligible long-term ramification.  When it's all said and done great software is more about the veneer (what can be seen and experienced) than the guts.  Developers forget that.

I'm an example of concentrating too much on the crafting and not enough on the creating.  I've produced far less than I hoped.  I've been overly perfectionistic, practically to the same ridicuous degree I read about in [Dreaming In Code](http://www.dreamingincode.com/).  I've more than once scrapped months of work because I wasn't satisfied with the results.  What I learned is this.  You can make great software with merely good code.  Perfectionism very often impedes creativity.  Creativity creates.  Users could care less about technologies, platforms and OOP vs. FP.  What they care about is that you made something that matters to them.  They'll never be bothered by the underpinnings and flaws if for a reasonable cost it provides a good overall experience.

The idea is not to sharpen your axe so that a single stroke fells a tree, it's to make ready for work to get done.  The manner matters but it's not superior to getting things done.  At the end of the day, the guy everyone wants back is the the one who got it done not the one with the best technique.  Great software needn't be perfect, it just needs to provide a good experience and meet a real need.  

Be prolific, not perfect.