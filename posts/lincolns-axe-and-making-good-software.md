I'm fond of Abraham Lincoln's quote: "Give me six hours to chop down a tree and I will spend the first four sharpening the axe."  It's true that a little preparation goes a long way.  I've thought about how that principle applies to knowledge work like programming. 

![Axe Sharpening](/images/axe-sharpening.gif)
When it comes to making something, we often start by choosing the technologies on which to build our foundation.  What complicates that is an ever changing technological landscape.  I started web development in the days of what is now called Classic ASP.  As with every technology, newer, shinier technologies rendered it obsolete.  I decided to retool and set out to find a platform that was open source despite the fact that paying jobs in the area favored Microsoft platforms.  

After spending almost a month exploring the possibilities and methodologically eliminating them, I settled on Rails.  Up until that time I had been using my own homegrown ASP framework which, as tossed together as it was, espoused the Rails-touted idea of convention over configuration.  It was philosophical similarities like that which reassured me that I had chosen well. I engrossed myself in the language and the community and was loving every discovery.  Watching Ryan Bates share his [Ruby wizardry](http://railscasts.com/) was both entertaining and practical.  The Ruby-space looked like a wonderful place.  Wanting to avoid another extensive retooling I hoped this would be the platform to end all platforms.

I gobbled up at least a dozen Rails and Ruby books and I built my church an elaborate Radiant CMS [site](https://github.com/daybreak/daybreak) with a host of customizations including Google calendar integration at a time when no established Ruby clients existed.  I was mesmerized by Ruby and thought I might scratch some of my own itches.  I started a project building the server code first.  When I got around to the client I noticed that I was having to build a lot of the same back end constructs.  This troubled me and I began searching for ways to overcome the issue. 

I discovered Node.  This was perhaps a couple years after its release.  I had heard about it but had never really understood exactly what is was or what I might gain by using it.  That was before I realized the benefit of JavaScript on the server: shared code.  The idea was both a blessing and a curse.  To capitalize on sharing code I had to now consider rewriting the back end in JavaScript.  It was around this time that I noticed the trend toward rich-client applications where back ends were nothing more than REST APIs. 

The [idea](http://martinfowler.com/eaaDev/SeparatedPresentation.html) was something that I mused over before.  During a project early in my career, I used [pkzip]( http://www.pkware.com/software/pkzip) as a means of handling compression within a larger system I was building.  Having primarily worked at developing Windows applications, I hadn't been seriously exposed to using or writing console applications and so I had not given much thought to their design.  (It would be some time before I would discover the Unix way and the beauty of piping single-purpose programs together.)  I began to notice that GUIs were built on top of console applications and I liked how this separated form from function.  This was perhaps when the immense value of separating concerns first dawned on me.  I started to wonder if every application shouldn't be doing this.

The idea reemerged when the service-oriented architecture gained popularity and I found myself on such a project.  I marveled again that the application was nothing more than a black box of business logic with a network interface.  I felt this was *the way* applications should be built.  Yet I wondered why the industry norm was to write [one big ball of form and function](http://blogs.adobe.com/paulw/archives/2007/09/presentation_pa_1.html).  

Fast forward almost a decade. 

The idea caught on and has become a popular way of building web apps.  Servers provide function and clients render form.  [Quite a few frameworks](http://todomvc.com/) have sprung up to support the paradigm.  As ever, the technological landscape continues to evolve. 

So although I had hoped when I dove into Ruby that I might remain a Rubyist indefinitely, I found once again that I had a compelling reason to move on.  Node was perfectly suited to this new paradigm of leaving the presentation to the client.  Add to that homogeneous client/server code and you have a match made in heaven.

That's how it goes in this business.  There are always new technologies rolling off the treadmill.  What you learn today may not make sense tomorrow.  (Fortunately, because [ideas are incremental](/dont-knock-originality) some of what we learn carries forward.)  For the most part learning is exciting for me and so riding the treadmill is as much love as it is labor.  I've made sharpening the axe a habit.  I perhaps even elevated the sharpening (knowing my craft) above the crafting (being fruitful). 

<aside>When it comes to technology "latest" doesn't necessarily equate to "greatest".  If anything, a technology is an amalgam of ideas and philosophies for how something should be done.  Yes, there will be some better ideas, but some are merely different.  Technology is by its very nature a proving ground and I'm not sold on the idea that newer is necessarily better.  After a decade PHP is getting along just fine.  Antiquated technologies can be used to great effect.</aside>

What prompted me to notice this was getting to know a coworker who made a side job of building software for small businesses.  He learns exactly what he needs to learn to get things done.  He's probably not the guy interested in studying design patterns and using the latest NoSQL database.  He's more fruitful, however, leaning on his competencies and building stuff that meets practical needs.  And his customers are satisfied.  He's exactly the kind of guy whose code I would have torn apart for failing to capitalize on the finer points of crafting good code.  I would have emphasized the craftsmanship itself.

But this guy was meeting real needs and without a complaint about his craftsmanship.  What his customers noticed was what everyone notices about software: its veneer and the kind of experience it offers.

The point is the main reason to learn a craft is to create and that perspiration should thus eclipse preparation.  The axe analogy as it applies to making good software is this: we sharpen the axe when we enrich our knowledge and we use the axe when we exercise it, particularly when we make stuff.  The latter produces both fruit and experience -- this is where the actual return on the sharpening is realized.

Making one more thing sometimes means knowing one less.  Thus the cost of learning one more framework is the project you might have created.  So what if you never write an application using CouchDB.  And maybe you never get around to learning EmberJS.  Knowing BackboneJS is good enough.  What's stopping you from building that site you've been meaning to make?  When it's all said and done great software is more about veneer (what can be seen and experienced) than guts.  Your customers will never care that you built the whole site in jQuery.  They care only about what you've actually built and what it means to them. 

There is a diminishing return on sharpening the axe.  There's a point at which the axe is as sharp as it need be to accomplish meaningful work.  What matters is creating useful things.  It's this that adds value to the world.