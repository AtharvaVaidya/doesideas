When it comes to crafting code, aesthetics matter and so I strive to beautify code.  By beautiful I mean succinct, articulate, and well structured.  Beautiful code is pleasant to read.  Beautiful code takes on a vocabulary that matches the domain.  That is, every application should be extracting what's routine about its work into abstractions that simplify the work.  Those abstractions make up a vocabulary, a means of expressing the most common patterns of work that needs doing.  A framework (or library) should neatly embody the abstractions that are practical to a domain.

And it's not enough to have an abstraction that simply meets a need. The manner should be both elegant and expressive so that it's a pleasure to use.  That's the essence of real beauty.  jQuery wasn't the first DOM manipulation API, but it is perhaps the most beautiful.  Using it invokes joy.  Is its popularity a coincidence?  I doubt it.  Beauty and happiness go hand in hand.  Beauty is an API that makes expressing domain problems a delight.

The most fundamental of all programming tenets is [Don't Repeat Yourself]( http://en.wikipedia.org/wiki/Don't_repeat_yourself).  This principal is about doing more with less.  That's why I revel in deleting entire sections of code.  I love having less code accomplish what more once did.  The most beautiful code is that which never had to be written.  Developers should prune ruthlessly.  Doing so adheres to the notion that "Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away."  Beauty is less code.

One of my most enlightened moments was realizing the intrinsic beauty of narrowing your primitives.  I'll explain.  A framework is made to embody the abstractions useful to a domain.  And less code is better than more code.  The core abstractions that we use and reuse – our building blocks – make up our body of primitives.  Thus, we achieve greater beauty when within our domain we can neatly accomplish the same work with fewer abstractions than with more.  The fewer artifacts you can get away with depending on the better.  Sometimes upon reviewing our framework, I notice missed opportunities for abstractions to share components or other creative ways to eliminate abstractions that once looked necessary.  This might involve creating more fundamental abstractions that can be better reused.  It might involve replacing a simple class with the most basic abstraction: a lambda.  jQuery is the epitome of minding your primitives.  Most every operation on a jQuery object begets another jQuery object.  Beauty is making use of fewer primitives.  A primitive which begets primitives of its own kind is practically perfection.
 
When working within a section of code I'm mindful of the beauty of my surroundings.  I'm a craftsman at heart so I can't help it.  I'm bothered if things are not in good order, if the code is verbose, if the structuring is not conducive to easing maintenance.  I can't help when I'm already in a room fixing a broken light switch not to also repair the door hinge.  I want the room to be a nice place to visit.  It's this sense that I should [leave things better than I found them](http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule).  This means I usually go beyond the bounds of a work ticket.  When I spot a code smell, I scrub it.  I polish it.  It's second nature.  I'm conscientious and it bothers me when others aren't.

Only a grunt developer is satisfied when he produces working code having given no thought to tomorrow.  I'm not saying that code should anticipate potential future requirements – [that too]( http://en.wikipedia.org/wiki/You_aren't_gonna_need_it) can lead to bad code – just that it should be structured in a manner that will ease maintainance and extension when the time comes.  I'm not perfect by any stretch, but I always think about [maintainability](http://en.wikipedia.org/wiki/Maintainability).  Don't call yourself a craftsman unless you know what makes code maintainable.  Programmers who don't write brittle code.  Beauty is confidence when adding a feature.  It's paving the way for the next guy.

Likewise, I'm bothered by developers who fail to recognize that software problems (including bugs) originate beneath what is visible on the surface.  Don't address the symptom, identify the root.  Sometimes the root cause is a crumbling foundation.  A design which is sufficient in light of its initial requirements may become deficient under the strain of ongoing maintenance.  Just as homes age and need occasional renovations, so too do programs.  Beauty code that is periodically revisited by someone who cares.   

Ruby is the philosophy that code should be beautiful and that coding should promote programmer happiness.  It's no suprise that its community brims with enthusiasm and produces some of the nicest libraries and frameworks found in any language.  In my experience, the Ruby philosophy is not pervasive in enterprise shops.  Schedules, politics, and managerial commitments often take precedence.  Thus, programmers are often reduced to grunts.  How can this not affect quality?  Beauty is active and invigorating, not passive and trivial.  Those who value beauty craft better things; things that in turn are more pleasing to use.  So-called professionals who trivialize beauty miss that.

Though beauty itself is subjective, that it is more than just style is not.  It evokes emotion, yes.  It stirs us, definitely.  It's the pillar of craftsmanship, the reason so many of us happily park ourselves in front of text editors hour after hour after hour -- all for the sheer joy of crafting something we behold as beautiful.